if (length(df)!=2)
stop("Provide exactly two degrees of freedoms")
if (df[1]<0 || df[2]<0)
stop("Degree of freedoms cannot be negative")
choices <- c("left","right")
alt <- pmatch(truncation, choices)
truncation <- choices[alt]
if (length(truncation) > 1 || is.na(truncation))
stop("truncation must be one \"left\", \"right\"")
if (!missing(conf.level))
if (length(conf.level) != 1 || is.na(conf.level) ||
conf.level < 0 || conf.level > 1)
stop("conf.level must be a number between 0 and 1")
if (truncation=="left") {
if(df[1]==df[2]){
#compute RTM from the derived formula
n<-df[1]
x<-(n+cutoff^(2))/n
E.t1<-(sqrt(n)*gamma((n+1)/2))/(sqrt(pi)*gamma(n/2)*(pt(cutoff,n)))*(1/((n-1)*(x)^((n-1)/2)))
E.t2<-(sqrt(n)*gamma((n+1)/2)*sin(theta))/(sqrt(pi)*gamma(n/2)*(pt(cutoff,n)))*(1/((n-1)*(x)^((n-1)/2)))
#Perform numerical integration if DoF are not equal
}else{
#E(t1|t1>c)
RTM.t1 <- function(t1,t2){
n1<-df[1]
n2<-df[2]
theta<-theta
t1*dbvt(t1,t2,c(n1,n2),theta,cutoff,truncation = "left")
}
#E(t2|t1>c)
RTM.t2 <- function(t1,t2){
n1<-df[1]
n2<-df[2]
theta<-theta
cutoff<-cutoff
t2*dbvt(t1,t2,c(n1,n2),theta,cutoff,truncation = "left")
}
#The integral2 doest support inf so put large value for
#better approximation
E.t1<-integral2(RTM.t1,-100,cutoff,-100,100)$Q
E.t2<-integral2(RTM.t2,-100,cutoff,-100,100)$Q
}
RTM<-round(E.t1-E.t2,8)
#extract pre and post variables
t1<-data[,1]
t2<-data[,2]
#compute the treatment effect
delta<-round(mean(t1-t2+RTM),4)
#test the treatment effect by eliminating RTM
test<- t.test(t1-t2+RTM,conf.level=conf.level)
}else{
if(df[1]==df[2]){
#compute RTM from the derived formula
n<-df[1]
x<-(n+cutoff^(2))/n
E.t1<-(sqrt(n)*gamma((n+1)/2))/(sqrt(pi)*gamma(n/2)*(1-pt(cutoff,n)))*(1/((n-1)*(x)^((n-1)/2)))
E.t2<-(sqrt(n)*gamma((n+1)/2)*sin(theta))/(sqrt(pi)*gamma(n/2)*(1-pt(cutoff,n)))*(1/((n-1)*(x)^((n-1)/2)))
}else{
#E(t1|t1>c)
RTM.t1 <- function(t1,t2){
n1<-df[1]
n2<-df[2]
theta<-theta
t1*dbvt(t1,t2,c(n1,n2),theta,cutoff,truncation = "right")
}
#E(t2|t1>c)
RTM.t2 <- function(t1,t2){
n1<-df[1]
n2<-df[2]
theta<-theta
cutoff<-cutoff
t2*dbvt(t1,t2,c(n1,n2),theta,cutoff,truncation = "right")
}
#The integral2 doesn't support inf so put a large value for
#better approximation
E.t1<-integral2(RTM.t1,cutoff,100,-100,100)$Q
E.t2<-integral2(RTM.t2,cutoff,100,-100,100)$Q
}
RTM<-round(E.t1-E.t2,8)
#extract pre and post variables
t1<-data[,1]
t2<-data[,2]
#compute the treatment effect
delta<-round(mean(t1-t2-RTM),4)
#test the treatment effect by eliminating RTM
test<- t.test(t1-t2-RTM,conf.level=conf.level)
}
#confidence interval
cint<- test$conf.int
#extract p-value, test statistics
pval<- test$p.value
t.stat<-test$statistic
df<-test$parameter
estimates<-c(RTM,delta)
names(t.stat)<-"t"
names(estimates)<-c("RTM","Delta")
method<-"***TREATMENT MEANS UNDER REGRESSION TO THE MEAN***"
mu<-0
names(mu)<-"treatment effect"
dname <- deparse(substitute(data))
output<-list(statistic = t.stat,parameter=df, p.value = pval,alternative="two.sided",
estimate = estimates, null.value = mu, conf.int = cint,
method = method,data.name = dname)
attr(output, "class") <- "htest"
return(output)
}
library(RTM)
library(pracma)
library(PairedData)
data("Anorexia")
### The z-score of cutoff point
cutoff<-(mean(Anorexia[,1])-95)/sd(Anorexia[,1])
### Testing of treatment means under RTM
theta<-0.67
RTM<-RTM.T(data=Anorexia,df=c(16,15),theta=theta,cutoff =  cutoff,truncation =  "left")
RTM
RTM.T <-
function(data, df, theta, cutoff, truncation,
conf.level = 0.95)
{
#Checking the conditions
if (nrow(data)<3)
stop("The observations must be at least three")
if (length(df)!=2)
stop("Provide exactly two degrees of freedoms")
if (df[1]<0 || df[2]<0)
stop("Degree of freedoms cannot be negative")
choices <- c("left","right")
alt <- pmatch(truncation, choices)
truncation <- choices[alt]
if (length(truncation) > 1 || is.na(truncation))
stop("truncation must be one \"left\", \"right\"")
if (!missing(conf.level))
if (length(conf.level) != 1 || is.na(conf.level) ||
conf.level < 0 || conf.level > 1)
stop("conf.level must be a number between 0 and 1")
if (truncation=="left") {
if(df[1]==df[2]){
#compute RTM from the derived formula
n<-df[1]
x<-(n+cutoff^(2))/n
E.t1<-(sqrt(n)*gamma((n+1)/2))/(sqrt(pi)*gamma(n/2)*(pt(cutoff,n)))*(1/((n-1)*(x)^((n-1)/2)))
E.t2<-(sqrt(n)*gamma((n+1)/2)*sin(theta))/(sqrt(pi)*gamma(n/2)*(pt(cutoff,n)))*(1/((n-1)*(x)^((n-1)/2)))
#Perform numerical integration if DoF are not equal
}else{
#E(t1|t1>c)
RTM.t1 <- function(t,df,theta,cutoff,truncation){
t[1]*dbvt(t[1],t[2],df,theta,cutoff,truncation)
}
#E(t2|t1>c)
RTM.t2 <- function(t,df,theta,cutoff,truncation){
t[2]*dbvt(t[1],t[2],df,theta,cutoff,truncation)
}
# Define the infinite limits
lower_limit <- c(-Inf,-Inf)  # Lower limits for t1 and t2
upper_limit <- c(cutoff, Inf)     # Upper limits for t1 and t2
# Perform the double integration
E.t1 <- adaptIntegrate(RTM.t1, lower_limit, upper_limit,df=df,theta=theta,cutoff=cutoff,truncation="left")$integral
E.t2 <- adaptIntegrate(RTM.t2, lower_limit, upper_limit,df=df,theta=theta,cutoff=cutoff,truncation="left")$integral
}
RTM<-round(E.t1-E.t2,4)
#extract pre and post variables
t1<-as.matrix(data)[,1]
t2<-as.matrix(data)[,2]
#test the treatment effect by eliminating RTM
test<- t.test(t1-t2+RTM,conf.level=conf.level)
#compute the treatment effect
delta<-round(test$estimate,4)
}else{
if(df[1]==df[2]){
#compute RTM from the derived formula
n<-df[1]
x<-(n+cutoff^(2))/n
E.t1<-(sqrt(n)*gamma((n+1)/2))/(sqrt(pi)*gamma(n/2)*(1-pt(cutoff,n)))*(1/((n-1)*(x)^((n-1)/2)))
E.t2<-(sqrt(n)*gamma((n+1)/2)*sin(theta))/(sqrt(pi)*gamma(n/2)*(1-pt(cutoff,n)))*(1/((n-1)*(x)^((n-1)/2)))
}else{
#E(t1|t1>c)
RTM.t1 <- function(t,df,theta,cutoff,truncation){
t[1]*dbvt(t[1],t[2],df,theta,cutoff,truncation)
}
#E(t2|t1>c)
RTM.t2 <- function(t,df,theta,cutoff,truncation){
t[2]*dbvt(t[1],t[2],df,theta,cutoff,truncation)
}
# Define the infinite limits
lower_limit <- c(cutoff,-Inf)  # Lower limits for t1 and t2
upper_limit <- c(Inf, Inf)     # Upper limits for t1 and t2
# Perform the double integration
E.t1 <- adaptIntegrate(RTM.t1, lower_limit, upper_limit,df=df,theta=theta,cutoff=cutoff,truncation="right")$integral
E.t2 <- adaptIntegrate(RTM.t2, lower_limit, upper_limit,df=df,theta=theta,cutoff=cutoff,truncation="right")$integral
}
RTM<-round(E.t1-E.t2,4)
#extract pre and post variables
t1<-data[,1]
t2<-data[,2]
#test the treatment effect by eliminating RTM
test<- t.test(t1-t2-RTM,conf.level=conf.level)
#compute the treatment effect
delta<-round(test$estimate,4)
}
#confidence interval
cint<- test$conf.int
#extract p-value, test statistics
pval<- test$p.value
t.stat<-test$statistic
df<-test$parameter
estimates<-c(RTM,delta)
names(t.stat)<-"t"
names(estimates)<-c("RTM","Delta")
method<-"***TREATMENT MEANS UNDER REGRESSION TO THE MEAN***"
mu<-0
names(mu)<-"treatment effect"
dname <- deparse(substitute(data))
output<-list(statistic = t.stat,parameter=df, p.value = pval,alternative="two.sided",
estimate = estimates, null.value = mu, conf.int = cint,
method = method,data.name = dname)
attr(output, "class") <- "htest"
return(output)
}
library(RTM)
devtools::load_all(".")
devtools::load_all(".")
rm(list = c("RTM.T"))
devtools::load_all(".")
?rbvt()
rbvt(1000)
rbvt(1000,df=2)
rbvt(1000,df=c(9,32,2))
rbvt(1000,df=c(9,10))
rbvt(1000,df=c(9,10),theta = pi/4)
t<-rbvt(1000,df=c(9,10),theta = pi/4)
dbvt(t[,1],t[,2],df=c(9,10),theta = pi/4)
devtools::load_all(".")
library(RTM)
devtools::load_all(".")
use_version("minor")
library(devtools)
use_version("minor")
library(RTM)
devtools::load_all(".")
devtools::install_github('umair-statistics/RTM')
library(RTM)
devtools::load_all(".")
library(RTM)
devtools::load_all(".")
library(RTM)
devtools::load_all(".")
library(RTM)
dbvt(0.5,1.4,c(15,7),0)
dt(0.5,15)*dt(1.4,7)
t1<-sqrt(15/rchisq(100,15))*rnorm(100)
t1
hist(t1)
t2<-(rnorm(100)*cos(pi/4)+sin(pi/4)*sqrt(rchisq(100,15)/15)*t1)/(sqrt(rchisq(100,9)/9))
t2
hist(t2)
cor(t1,t2)
pi/4
NLL.Trunc = function(pars, data) {
# Extract parameters from the vector
n1<-pars[1]
n2<-pars[2]
theta = pars[3]
t1<-data[,1]
t2<-data[,2]
# Calculate Negative Log-Likelihood
suppressWarnings(-sum(log(dbvt(t1,t2,df=c(n1,n2),theta=theta))))
}
mle = optim(par = c(n1 = 15,n2=9,theta=0.5), fn = NLL.Trunc, data =cbind(t1,t2),
control = list(parscale = c(n1 = 15,n2=9,theta=0.5)))
library(RTM)
mle = optim(par = c(n1 = 15,n2=9,theta=0.5), fn = NLL.Trunc, data =cbind(t1,t2),
control = list(parscale = c(n1 = 15,n2=9,theta=0.5)))
mle$par
library(RTM)
t1<-sqrt(15/rchisq(1000,15))*rnorm(1000)
hist(t1)
t2<-(rnorm(1000)*cos(pi/4)+sin(pi/4)*sqrt(rchisq(1000,15)/15)*t1)/(sqrt(rchisq(1000,9)/9))
hist(t2)
NLL.Trunc = function(pars, data) {
# Extract parameters from the vector
n1<-pars[1]
n2<-pars[2]
theta = pars[3]
t1<-data[,1]
t2<-data[,2]
# Calculate Negative Log-Likelihood
suppressWarnings(-sum(log(dbvt(t1,t2,df=c(n1,n2),theta=theta))))
}
mle = optim(par = c(n1 = 15,n2=9,theta=0.5), fn = NLL.Trunc, data =cbind(t1,t2),
control = list(parscale = c(n1 = 15,n2=9,theta=0.5)))
mle$par
pi/4
library(RTM)
t1<-sqrt(15/rchisq(10000,15))*rnorm(10000)
hist(t1)
t2<-(rnorm(10000)*cos(pi/4)+sin(pi/4)*sqrt(rchisq(10000,15)/15)*t1)/(sqrt(rchisq(10000,9)/9))
hist(t2)
NLL.Trunc = function(pars, data) {
# Extract parameters from the vector
n1<-pars[1]
n2<-pars[2]
theta = pars[3]
t1<-data[,1]
t2<-data[,2]
# Calculate Negative Log-Likelihood
suppressWarnings(-sum(log(dbvt(t1,t2,df=c(n1,n2),theta=theta))))
}
mle = optim(par = c(n1 = 15,n2=9,theta=0.5), fn = NLL.Trunc, data =cbind(t1,t2),
control = list(parscale = c(n1 = 15,n2=9,theta=0.5)))
mle$par
pi/4
library(RTM)
t1<-sqrt(15/rchisq(10000,15))*rnorm(10000)
hist(t1)
t2<-(rnorm(10000)*cos(pi/4)+sin(pi/4)*sqrt(rchisq(10000,15)/15)*t1)/(sqrt(rchisq(10000,9)/9))
hist(t2)
den<-function(t1,t2,df,theta){
del<-(t1^2+t2^2-2*t1*t2*sin(theta))/(cos(theta))^2
return(1/(2*pi*cos(theta))*(1/(1+del/df)^(df/2+1)))
}
dbvt
dbvt(0.5,1,c(15,15),pi/4)
den(0.5,1,15,pi/4)
dbvt(2.7,1.5,c(45,45),pi/4)
den(2.7,1.5,45,pi/4)
rbvt(100,c(15,20),pi/4)
k<-rbvt(100,c(15,20),pi/4)
ks.test(rnorm(100),"pnorm",0,1)
ks.test(rpois(100),"pnorm",0,1)
ks.test(rpois(100),"pnorm",2)
ks.test(rpois(100,4),"pnorm",2)
ks.test(rpois(100,4),"pnorm",2)
k[,1]
ks.test(k[,1],"pt",15)
ks.test(k[,1],"pt",20)
ks.test(k[,1],"pt",100)
ks.test(k[,1],"pt",500)
ks.test(k[,1],"pt",1)
ks.test(k[,1],"pt",2)
ks.test(k[,1],"pt",3)
ks.test(k[,1],"pt",4)
ks.test(k[,1],"pt",5)
ks.test(k[,1],"pt",15)
ks.test(k[,1],"pt",20)
t1
ks.test(t1,"pt",20)
library(RTM)
t1<-sqrt(15/rchisq(10000,15))*rnorm(10000)
t2<-(rnorm(10000)*cos(pi/4)+sin(pi/4)*sqrt(rchisq(10000,15)/15)*t1)/(sqrt(rchisq(10000,9)/9))
ks.test(t1,"pt",15)
ks.test(t1,"pt",16)
ks.test(t1,"pt",17)
ks.test(t1,"pt",18)
ks.test(t1,"pt",19)
ks.test(t1,"pt",1)
ks.test(t1,"pt",2)
ks.test(t1,"pt",3)
ks.test(t1,"pt",4)
ks.test(t1,"pt",5)
ks.test(t1,"pt",6)
ks.test(t1,"pt",7)
ks.test(t1,"pt",8)
ks.test(t1,"pt",9)
ks.test(t1,"pt",10)
ks.test(t1,"pt",100)
ks.test(t2,"pt",100)
ks.test(t2,"pt",15)
ks.test(t2,"pt",10)
ks.test(t2,"pt",11)
ks.test(t2,"pt",2)
ks.test(t2,"pt",3)
t1<-sqrt(15/rchisq(100,15))*rnorm(100)
hist(t1)
t2<-(rnorm(100)*cos(pi/4)+sin(pi/4)*sqrt(rchisq(100,15)/15)*t1)/(sqrt(rchisq(100,9)/9))
hist(t2)
ks.test(t2,"pt",3)
ks.test(t2,"pt",9)
library(RTM)
t1<-sqrt(15/rchisq(100,15))*rnorm(100)
hist(t1)
t2<-(rnorm(100)*cos(pi/4)+sin(pi/4)*sqrt(rchisq(100,15)/15)*t1)/(sqrt(rchisq(100,9)/9))
hist(t2)
NLL.Trunc = function(pars, data) {
# Extract parameters from the vector
n1<-pars[1]
n2<-pars[2]
theta = pars[3]
t1<-data[,1]
t2<-data[,2]
# Calculate Negative Log-Likelihood
suppressWarnings(-sum(log(dbvt(t1,t2,df=c(n1,n2),theta=theta))))
}
mle = optim(par = c(n1 = 15,n2=9,theta=0.5), fn = NLL.Trunc, data =cbind(t1,t2),
control = list(parscale = c(n1 = 15,n2=9,theta=0.5)))
mle$par
pi/4
k<-rbvt(100,c(15,20),pi/4)
k
k<-rbvt(100,c(15,9),pi/4)
k
NLL = function(pars, data) {
# Extract parameters from the vector
df<-pars[1]
theta = pars[2]
t1<-data[,1]
t2<-data[,2]
# Calculate Negative Log-Likelihood
suppressWarnings(-sum(log(den(t1,t2,df,theta=theta))))
}
k<-rbvt(100,c(15,15),pi/4)
NLL = function(pars, data) {
# Extract parameters from the vector
df<-pars[1]
theta = pars[2]
t1<-data[,1]
t2<-data[,2]
# Calculate Negative Log-Likelihood
suppressWarnings(-sum(log(den(t1,t2,df,theta=theta))))
}
mle = optim(par = c(df = 10,theta=0.5), fn = NLL, data =k,
control = list(parscale = c(df = 10,theta=0.5)))
mle
k
mle = optim(par = c(df = 10,theta=0.5), fn = NLL, data =k,
control = list(parscale = c(df = 10,theta=0.5)))
mle
k<-rbvt(100,c(15,15),pi/4)
NLL = function(pars, data) {
# Extract parameters from the vector
df<-pars[1]
theta = pars[2]
t1<-data[,1]
t2<-data[,2]
# Calculate Negative Log-Likelihood
suppressWarnings(-sum(log(den(t1,t2,df,theta=theta))))
}
mle$par
k<-rbvt(100,c(15,15),pi/4)
NLL = function(pars, data) {
# Extract parameters from the vector
df<-pars[1]
theta = pars[2]
t1<-data[,1]
t2<-data[,2]
# Calculate Negative Log-Likelihood
suppressWarnings(-sum(log(den(t1,t2,df,theta=theta))))
}
mle = optim(par = c(df = 10,theta=0.5), fn = NLL, data =k,
control = list(parscale = c(df = 10,theta=0.5)))
mle$par
NLL = function(pars, data) {
# Extract parameters from the vector
df<-pars[1]
theta = pars[2]
t1<-data[,1]
t2<-data[,2]
# Calculate Negative Log-Likelihood
suppressWarnings(-sum(log(den(t1,t2,df,theta=theta))))
}
mle = optim(par = c(df = 10,theta=0.5), fn = NLL, data =k,
control = list(parscale = c(df = 10,theta=0.5)))
mle$par
k<-rbvt(100,c(15,15),pi/4)
NLL = function(pars, data) {
# Extract parameters from the vector
df<-pars[1]
theta = pars[2]
t1<-data[,1]
t2<-data[,2]
# Calculate Negative Log-Likelihood
suppressWarnings(-sum(log(den(t1,t2,df,theta=theta))))
}
mle = optim(par = c(df = 10,theta=0.5), fn = NLL, data =k,
control = list(parscale = c(df = 10,theta=0.5)))
mle$par
k<-rbvt(100,c(15,15),pi/4)
NLL = function(pars, data) {
# Extract parameters from the vector
df<-pars[1]
theta = pars[2]
t1<-data[,1]
t2<-data[,2]
# Calculate Negative Log-Likelihood
suppressWarnings(-sum(log(den(t1,t2,df,theta=theta))))
}
mle = optim(par = c(df = 10,theta=0.5), fn = NLL, data =k,
control = list(parscale = c(df = 10,theta=0.5)))
mle$par
devtools::load_all(".")
library(RTM)
rt()
2+2
devtools::load_all(".")
library(RTM)
devtools::load_all(".")
library(RTM)
dt <- rbvt(1000,c(9,9),pi/6)
library(RTM)
library(dplyr)
library(BSDA)
install.packages("gitcreds")
gitcreds::gitcreds_set()
devtools::load_all(".")
warnings()
devtools::load_all(".")
devtools::load_all(".")
devtools::document()
devtools::document()
devtools::document()
remove.packages("RTM")
devtools::build()
